정렬 - 데이터를 특정한 기준에 따라서 순서대로 나열
데이터를 가공할 때 오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해서 사용하는 경우가 많음
-> 선택, 삽입, 퀵, 계수 정렬
-> 오름차순을 위한 소스코드만을 다룸

선택정렬 알고리즘
무작위로 여러개가 있을 경우
가장 작은 데이터를 선택 -> 맨 앞에 있는 데이터와 바꿈 -> 그 다음 작은 데이터 선택 -> 두번째 데이터와 바꿈.....

예제) 7 1 9 2 6 3 5 0 4 8
->   1 7 9 2 6 3 5 0 4 8
->   1 2 9 7 6 3 5 0 4 8
->   1 2 3 7 6 9 5 0 4 8.....

삽입정렬 알고리즘
데이터가 거의 정렬 되어 있을 때는 효율적이다.
특정한 데이터를 적절한 위치에 삽입

예제) 7 1 9 2 6 3 5 0 4 8
->   1 7 9 2 6 3 5 0 4 8
->   1 7 9 2 6 3 5 0 4 8
->   1 2 7 9 6 3 5 0 4 8 ....

퀵정렬 알고리즘
기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.
퀵 정렬에는 피벗이 사용됨 -> 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 기준
호어 분할 -> 리스트에서 첫번째 데이터를 피벗으로 정한다.

예제) 7 1 9 2 6 3 5 0 4 8
->   7 1 4 2 0 3 5 6 9 8  -> 7을 기준으로 왼쪽에서 7보다 큰것을 찾고 오른쪽에서 7보다 작은을 찾고 서로 교환
->   1 4 2 0 3 5 6 7 9 8  -> 피벗을 위치로 옮김   7기준으로 왼쪽것을 반복, 오른쪽 것을 반복

평균 시간복잡도는 O(NlogN)
최악 시간복잡도는 O(N^2) -> 이미 데이터가 정렬되어 있는 경우 매우 느리게 동작


계수 정렬 알고리즘
특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
데이터의 크기 범위가 제한 되어 정수 형태로 표현할 수 있을 때만 사용 가능
-> 계수 정렬을 이용할 때는 모든 범위를 담을 수 있는 크기의 리스트를 선언 해야 하기 때문이다.

예제) 7 1 9 2 6 3 5 0 4 8
[0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
 1   1   1   1   1   1   1   1   1   1

데이터의 개수를 N, 데이터 중 최댓값의 크기를 K -> O(N + K)
기수 정렬과 더불어 가장 빠름
때에 따라서 심각한 비효율성
-> 0 과 999,999 단 2개만 존재할 때 리스트의 크기가 100만개 선언해야함

